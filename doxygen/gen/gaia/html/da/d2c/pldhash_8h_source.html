<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FxOS Code Reading: pldhash.h ソースファイル</title>

<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">FxOS Code Reading
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- 作成： Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>メインページ</span></a></li>
      <li><a href="../../pages.html"><span>関連ページ</span></a></li>
      <li><a href="../../modules.html"><span>モジュール</span></a></li>
      <li><a href="../../namespaces.html"><span>パッケージ</span></a></li>
      <li><a href="../../annotated.html"><span>データ構造</span></a></li>
      <li class="current"><a href="../../files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>ファイル一覧</span></a></li>
      <li><a href="../../globals.html"><span>グローバル</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('da/d2c/pldhash_8h.html','../../');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">pldhash.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../da/d2c/pldhash_8h.html">説明を見る。</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */</span>
<a name="l00002"></a>00002 <span class="comment">/* This Source Code Form is subject to the terms of the Mozilla Public</span>
<a name="l00003"></a>00003 <span class="comment"> * License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<a name="l00004"></a>00004 <span class="comment"> * file, You can obtain one at http://mozilla.org/MPL/2.0/. */</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#ifndef pldhash_h___</span>
<a name="l00007"></a>00007 <span class="preprocessor"></span><span class="preprocessor">#define pldhash_h___</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00009"></a>00009 <span class="comment"> * Double hashing, a la Knuth 6.</span>
<a name="l00010"></a>00010 <span class="comment"> */</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;<a class="code" href="../../db/d6d/_memory_reporting_8h.html">mozilla/MemoryReporting.h</a>&quot;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &quot;<a class="code" href="../../d9/dae/mozilla_2_types_8h.html">mozilla/Types.h</a>&quot;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &quot;<a class="code" href="../../d3/dd8/nscore_8h.html">nscore.h</a>&quot;</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00017"></a>00017 <span class="preprocessor">#endif</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span>
<a name="l00019"></a>00019 <span class="preprocessor">#if defined(__GNUC__) &amp;&amp; defined(__i386__) &amp;&amp; !defined(XP_OS2)</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_FASTCALL __attribute__ ((regparm (3),stdcall))</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#elif defined(XP_WIN)</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_FASTCALL __fastcall</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00024"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a587e8c78b36d501dad502ea7cee7ff2e">00024</a> <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_FASTCALL</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 <span class="preprocessor">#ifdef DEBUG_XXXbrendan</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASHMETER 1</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="comment">/* Table size limit, do not equal or exceed (see min&amp;maxAlphaFrac, below). */</span>
<a name="l00032"></a>00032 <span class="preprocessor">#undef PL_DHASH_SIZE_LIMIT</span>
<a name="l00033"></a><a class="code" href="../../da/d2c/pldhash_8h.html#aa26967ae2e1046df747917b8bbbb0c1e">00033</a> <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_SIZE_LIMIT     ((uint32_t)1 &lt;&lt; 24)</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span>
<a name="l00035"></a>00035 <span class="comment">/* Minimum table size, or gross entry count (net is at most .75 loaded). */</span>
<a name="l00036"></a>00036 <span class="preprocessor">#ifndef PL_DHASH_MIN_SIZE</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_MIN_SIZE 16</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#elif (PL_DHASH_MIN_SIZE &amp; (PL_DHASH_MIN_SIZE - 1)) != 0</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#error &quot;PL_DHASH_MIN_SIZE must be a power of two!&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="comment">/*</span>
<a name="l00043"></a>00043 <span class="comment"> * Multiplicative hash uses an unsigned 32 bit integer and the golden ratio,</span>
<a name="l00044"></a>00044 <span class="comment"> * expressed as a fixed-point 32-bit fraction.</span>
<a name="l00045"></a>00045 <span class="comment"> */</span>
<a name="l00046"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a0204af8a62c2f4e34a0504849e0e6e11">00046</a> <span class="preprocessor">#define PL_DHASH_BITS           32</span>
<a name="l00047"></a><a class="code" href="../../da/d2c/pldhash_8h.html#afde0ffbbb089c9ff6f014b192ea05f30">00047</a> <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_GOLDEN_RATIO   0x9E3779B9U</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00049"></a>00049 <span class="comment">/* Primitive and forward-struct typedefs. */</span>
<a name="l00050"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a6b7adbc70882ca136a7949ca49024cf2">00050</a> <span class="keyword">typedef</span> uint32_t                <a class="code" href="../../da/d2c/pldhash_8h.html#a6b7adbc70882ca136a7949ca49024cf2">PLDHashNumber</a>;
<a name="l00051"></a><a class="code" href="../../da/d2c/pldhash_8h.html#ab9f25a02893c4629c434026b3bb84a74">00051</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a>  <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a>;
<a name="l00052"></a><a class="code" href="../../da/d2c/pldhash_8h.html#aad84b307a6a819c17824611f217885eb">00052</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d7/d5c/struct_p_l_d_hash_entry_stub.html">PLDHashEntryStub</a> <a class="code" href="../../d7/d5c/struct_p_l_d_hash_entry_stub.html">PLDHashEntryStub</a>;
<a name="l00053"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a0507602df70b53b4fcefeb54da1c1f43">00053</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a>     <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a>;
<a name="l00054"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a40b46b1464980b8e56fc6da4a429ede6">00054</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html">PLDHashTableOps</a>  <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html">PLDHashTableOps</a>;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/*</span>
<a name="l00057"></a>00057 <span class="comment"> * Table entry header structure.</span>
<a name="l00058"></a>00058 <span class="comment"> *</span>
<a name="l00059"></a>00059 <span class="comment"> * In order to allow in-line allocation of key and value, we do not declare</span>
<a name="l00060"></a>00060 <span class="comment"> * either here.  Instead, the API uses const void *key as a formal parameter.</span>
<a name="l00061"></a>00061 <span class="comment"> * The key need not be stored in the entry; it may be part of the value, but</span>
<a name="l00062"></a>00062 <span class="comment"> * need not be stored at all.</span>
<a name="l00063"></a>00063 <span class="comment"> *</span>
<a name="l00064"></a>00064 <span class="comment"> * Callback types are defined below and grouped into the PLDHashTableOps</span>
<a name="l00065"></a>00065 <span class="comment"> * structure, for single static initialization per hash table sub-type.</span>
<a name="l00066"></a>00066 <span class="comment"> *</span>
<a name="l00067"></a>00067 <span class="comment"> * Each hash table sub-type should nest the PLDHashEntryHdr structure at the</span>
<a name="l00068"></a>00068 <span class="comment"> * front of its particular entry type.  The keyHash member contains the result</span>
<a name="l00069"></a>00069 <span class="comment"> * of multiplying the hash code returned from the hashKey callback (see below)</span>
<a name="l00070"></a>00070 <span class="comment"> * by PL_DHASH_GOLDEN_RATIO, then constraining the result to avoid the magic 0</span>
<a name="l00071"></a>00071 <span class="comment"> * and 1 values.  The stored keyHash value is table size invariant, and it is</span>
<a name="l00072"></a>00072 <span class="comment"> * maintained automatically by PL_DHashTableOperate -- users should never set</span>
<a name="l00073"></a>00073 <span class="comment"> * it, and its only uses should be via the entry macros below.</span>
<a name="l00074"></a>00074 <span class="comment"> *</span>
<a name="l00075"></a>00075 <span class="comment"> * The PL_DHASH_ENTRY_IS_LIVE macro tests whether entry is neither free nor</span>
<a name="l00076"></a>00076 <span class="comment"> * removed.  An entry may be either busy or free; if busy, it may be live or</span>
<a name="l00077"></a>00077 <span class="comment"> * removed.  Consumers of this API should not access members of entries that</span>
<a name="l00078"></a>00078 <span class="comment"> * are not live.</span>
<a name="l00079"></a>00079 <span class="comment"> *</span>
<a name="l00080"></a>00080 <span class="comment"> * However, use PL_DHASH_ENTRY_IS_BUSY for faster liveness testing of entries</span>
<a name="l00081"></a>00081 <span class="comment"> * returned by PL_DHashTableOperate, as PL_DHashTableOperate never returns a</span>
<a name="l00082"></a>00082 <span class="comment"> * non-live, busy (i.e., removed) entry pointer to its caller.  See below for</span>
<a name="l00083"></a>00083 <span class="comment"> * more details on PL_DHashTableOperate&#39;s calling rules.</span>
<a name="l00084"></a>00084 <span class="comment"> */</span>
<a name="l00085"></a><a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">00085</a> <span class="keyword">struct </span><a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> {
<a name="l00086"></a><a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html#a17951a4bdb41ab8d0866a8bc959df910">00086</a>     PLDHashNumber       <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html#a17951a4bdb41ab8d0866a8bc959df910">keyHash</a>;        <span class="comment">/* every entry must begin like this */</span>
<a name="l00087"></a>00087 };
<a name="l00088"></a>00088 
<a name="l00089"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a3e2812e3005bef693804e6945d52e4e6">00089</a> <span class="preprocessor">#define PL_DHASH_ENTRY_IS_FREE(entry)   ((entry)-&gt;keyHash == 0)</span>
<a name="l00090"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a26da5d8e24fe4594fda95a9ca446c6cd">00090</a> <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_ENTRY_IS_BUSY(entry)   (!PL_DHASH_ENTRY_IS_FREE(entry))</span>
<a name="l00091"></a><a class="code" href="../../da/d2c/pldhash_8h.html#af107d7be754da9ba163dc3d7d7171795">00091</a> <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_ENTRY_IS_LIVE(entry)   ((entry)-&gt;keyHash &gt;= 2)</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="comment">/*</span>
<a name="l00094"></a>00094 <span class="comment"> * A PLDHashTable is currently 8 words (without the PL_DHASHMETER overhead)</span>
<a name="l00095"></a>00095 <span class="comment"> * on most architectures, and may be allocated on the stack or within another</span>
<a name="l00096"></a>00096 <span class="comment"> * structure or class (see below for the Init and Finish functions to use).</span>
<a name="l00097"></a>00097 <span class="comment"> *</span>
<a name="l00098"></a>00098 <span class="comment"> * To decide whether to use double hashing vs. chaining, we need to develop a</span>
<a name="l00099"></a>00099 <span class="comment"> * trade-off relation, as follows:</span>
<a name="l00100"></a>00100 <span class="comment"> *</span>
<a name="l00101"></a>00101 <span class="comment"> * Let alpha be the load factor, esize the entry size in words, count the</span>
<a name="l00102"></a>00102 <span class="comment"> * entry count, and pow2 the power-of-two table size in entries.</span>
<a name="l00103"></a>00103 <span class="comment"> *</span>
<a name="l00104"></a>00104 <span class="comment"> *   (PLDHashTable overhead)    &gt; (PLHashTable overhead)</span>
<a name="l00105"></a>00105 <span class="comment"> *   (unused table entry space) &gt; (malloc and .next overhead per entry) +</span>
<a name="l00106"></a>00106 <span class="comment"> *                                (buckets overhead)</span>
<a name="l00107"></a>00107 <span class="comment"> *   (1 - alpha) * esize * pow2 &gt; 2 * count + pow2</span>
<a name="l00108"></a>00108 <span class="comment"> *</span>
<a name="l00109"></a>00109 <span class="comment"> * Notice that alpha is by definition (count / pow2):</span>
<a name="l00110"></a>00110 <span class="comment"> *</span>
<a name="l00111"></a>00111 <span class="comment"> *   (1 - alpha) * esize * pow2 &gt; 2 * alpha * pow2 + pow2</span>
<a name="l00112"></a>00112 <span class="comment"> *   (1 - alpha) * esize        &gt; 2 * alpha + 1</span>
<a name="l00113"></a>00113 <span class="comment"> *</span>
<a name="l00114"></a>00114 <span class="comment"> *   esize &gt; (1 + 2 * alpha) / (1 - alpha)</span>
<a name="l00115"></a>00115 <span class="comment"> *</span>
<a name="l00116"></a>00116 <span class="comment"> * This assumes both tables must keep keyHash, key, and value for each entry,</span>
<a name="l00117"></a>00117 <span class="comment"> * where key and value point to separately allocated strings or structures.</span>
<a name="l00118"></a>00118 <span class="comment"> * If key and value can be combined into one pointer, then the trade-off is:</span>
<a name="l00119"></a>00119 <span class="comment"> *</span>
<a name="l00120"></a>00120 <span class="comment"> *   esize &gt; (1 + 3 * alpha) / (1 - alpha)</span>
<a name="l00121"></a>00121 <span class="comment"> *</span>
<a name="l00122"></a>00122 <span class="comment"> * If the entry value can be a subtype of PLDHashEntryHdr, rather than a type</span>
<a name="l00123"></a>00123 <span class="comment"> * that must be allocated separately and referenced by an entry.value pointer</span>
<a name="l00124"></a>00124 <span class="comment"> * member, and provided key&#39;s allocation can be fused with its entry&#39;s, then</span>
<a name="l00125"></a>00125 <span class="comment"> * k (the words wasted per entry with chaining) is 4.</span>
<a name="l00126"></a>00126 <span class="comment"> *</span>
<a name="l00127"></a>00127 <span class="comment"> * To see these curves, feed gnuplot input like so:</span>
<a name="l00128"></a>00128 <span class="comment"> *</span>
<a name="l00129"></a>00129 <span class="comment"> *   gnuplot&gt; f(x,k) = (1 + k * x) / (1 - x)</span>
<a name="l00130"></a>00130 <span class="comment"> *   gnuplot&gt; plot [0:.75] f(x,2), f(x,3), f(x,4)</span>
<a name="l00131"></a>00131 <span class="comment"> *</span>
<a name="l00132"></a>00132 <span class="comment"> * For k of 2 and a well-loaded table (alpha &gt; .5), esize must be more than 4</span>
<a name="l00133"></a>00133 <span class="comment"> * words for chaining to be more space-efficient than double hashing.</span>
<a name="l00134"></a>00134 <span class="comment"> *</span>
<a name="l00135"></a>00135 <span class="comment"> * Solving for alpha helps us decide when to shrink an underloaded table:</span>
<a name="l00136"></a>00136 <span class="comment"> *</span>
<a name="l00137"></a>00137 <span class="comment"> *   esize                     &gt; (1 + k * alpha) / (1 - alpha)</span>
<a name="l00138"></a>00138 <span class="comment"> *   esize - alpha * esize     &gt; 1 + k * alpha</span>
<a name="l00139"></a>00139 <span class="comment"> *   esize - 1                 &gt; (k + esize) * alpha</span>
<a name="l00140"></a>00140 <span class="comment"> *   (esize - 1) / (k + esize) &gt; alpha</span>
<a name="l00141"></a>00141 <span class="comment"> *</span>
<a name="l00142"></a>00142 <span class="comment"> *   alpha &lt; (esize - 1) / (esize + k)</span>
<a name="l00143"></a>00143 <span class="comment"> *</span>
<a name="l00144"></a>00144 <span class="comment"> * Therefore double hashing should keep alpha &gt;= (esize - 1) / (esize + k),</span>
<a name="l00145"></a>00145 <span class="comment"> * assuming esize is not too large (in which case, chaining should probably be</span>
<a name="l00146"></a>00146 <span class="comment"> * used for any alpha).  For esize=2 and k=3, we want alpha &gt;= .2; for esize=3</span>
<a name="l00147"></a>00147 <span class="comment"> * and k=2, we want alpha &gt;= .4.  For k=4, esize could be 6, and alpha &gt;= .5</span>
<a name="l00148"></a>00148 <span class="comment"> * would still obtain.  See the PL_DHASH_MIN_ALPHA macro further below.</span>
<a name="l00149"></a>00149 <span class="comment"> *</span>
<a name="l00150"></a>00150 <span class="comment"> * The current implementation uses a configurable lower bound on alpha, which</span>
<a name="l00151"></a>00151 <span class="comment"> * defaults to .25, when deciding to shrink the table (while still respecting</span>
<a name="l00152"></a>00152 <span class="comment"> * PL_DHASH_MIN_SIZE).</span>
<a name="l00153"></a>00153 <span class="comment"> *</span>
<a name="l00154"></a>00154 <span class="comment"> * Note a qualitative difference between chaining and double hashing: under</span>
<a name="l00155"></a>00155 <span class="comment"> * chaining, entry addresses are stable across table shrinks and grows.  With</span>
<a name="l00156"></a>00156 <span class="comment"> * double hashing, you can&#39;t safely hold an entry pointer and use it after an</span>
<a name="l00157"></a>00157 <span class="comment"> * ADD or REMOVE operation, unless you sample table-&gt;generation before adding</span>
<a name="l00158"></a>00158 <span class="comment"> * or removing, and compare the sample after, dereferencing the entry pointer</span>
<a name="l00159"></a>00159 <span class="comment"> * only if table-&gt;generation has not changed.</span>
<a name="l00160"></a>00160 <span class="comment"> *</span>
<a name="l00161"></a>00161 <span class="comment"> * The moral of this story: there is no one-size-fits-all hash table scheme,</span>
<a name="l00162"></a>00162 <span class="comment"> * but for small table entry size, and assuming entry address stability is not</span>
<a name="l00163"></a>00163 <span class="comment"> * required, double hashing wins.</span>
<a name="l00164"></a>00164 <span class="comment"> */</span>
<a name="l00165"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">00165</a> <span class="keyword">struct </span><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> {
<a name="l00166"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ad7a3479c013cc2f6730b4ff50939cd4b">00166</a>     <span class="keyword">const</span> <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html">PLDHashTableOps</a> *<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ad7a3479c013cc2f6730b4ff50939cd4b">ops</a>;         <span class="comment">/* virtual operations, see below */</span>
<a name="l00167"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ad5f03458762c9d1047cba0bf84b90dfa">00167</a>     <span class="keywordtype">void</span>                *<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ad5f03458762c9d1047cba0bf84b90dfa">data</a>;          <span class="comment">/* ops- and instance-specific data */</span>
<a name="l00168"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#a3d575f9c819f018b7564055fbe6414ad">00168</a>     int16_t             <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#a3d575f9c819f018b7564055fbe6414ad">hashShift</a>;      <span class="comment">/* multiplicative hash shift */</span>
<a name="l00169"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#af4ae541456d88845c893cf4f2a961beb">00169</a>     uint8_t             <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#af4ae541456d88845c893cf4f2a961beb">maxAlphaFrac</a>;   <span class="comment">/* 8-bit fixed point max alpha */</span>
<a name="l00170"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#a8c38126d24ee7c0b01312fe303687ae9">00170</a>     uint8_t             <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#a8c38126d24ee7c0b01312fe303687ae9">minAlphaFrac</a>;   <span class="comment">/* 8-bit fixed point min alpha */</span>
<a name="l00171"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#a4889605f6119505cb33bd75932cff535">00171</a>     uint32_t            <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#a4889605f6119505cb33bd75932cff535">entrySize</a>;      <span class="comment">/* number of bytes in an entry */</span>
<a name="l00172"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ac37642598cad6071bdaa75707f3ae3cf">00172</a>     uint32_t            <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ac37642598cad6071bdaa75707f3ae3cf">entryCount</a>;     <span class="comment">/* number of entries in table */</span>
<a name="l00173"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ae87e77f835d469356283c83d9fd0bf06">00173</a>     uint32_t            <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ae87e77f835d469356283c83d9fd0bf06">removedCount</a>;   <span class="comment">/* removed entry sentinels in table */</span>
<a name="l00174"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#a7827f9cfe5f6c5aea666898109cede3c">00174</a>     uint32_t            <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#a7827f9cfe5f6c5aea666898109cede3c">generation</a>;     <span class="comment">/* entry storage generation number */</span>
<a name="l00175"></a><a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ab5b95d1e7490e0b70244b02d50bbc276">00175</a>     <span class="keywordtype">char</span>                *<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html#ab5b95d1e7490e0b70244b02d50bbc276">entryStore</a>;    <span class="comment">/* entry storage */</span>
<a name="l00176"></a>00176 <span class="preprocessor">#ifdef PL_DHASHMETER</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>    <span class="keyword">struct </span>PLDHashStats {
<a name="l00178"></a>00178         uint32_t        searches;       <span class="comment">/* total number of table searches */</span>
<a name="l00179"></a>00179         uint32_t        <a class="code" href="../../db/d14/ftu_2js_2navigation_8js.html#ad117d2d9c0b9ecd5bad83acb2570e4b4">steps</a>;          <span class="comment">/* hash chain links traversed */</span>
<a name="l00180"></a>00180         uint32_t        hits;           <span class="comment">/* searches that found key */</span>
<a name="l00181"></a>00181         uint32_t        misses;         <span class="comment">/* searches that didn&#39;t find key */</span>
<a name="l00182"></a>00182         uint32_t        lookups;        <span class="comment">/* number of PL_DHASH_LOOKUPs */</span>
<a name="l00183"></a>00183         uint32_t        addMisses;      <span class="comment">/* adds that miss, and do work */</span>
<a name="l00184"></a>00184         uint32_t        addOverRemoved; <span class="comment">/* adds that recycled a removed entry */</span>
<a name="l00185"></a>00185         uint32_t        addHits;        <span class="comment">/* adds that hit an existing entry */</span>
<a name="l00186"></a>00186         uint32_t        addFailures;    <span class="comment">/* out-of-memory during add growth */</span>
<a name="l00187"></a>00187         uint32_t        removeHits;     <span class="comment">/* removes that hit, and do work */</span>
<a name="l00188"></a>00188         uint32_t        removeMisses;   <span class="comment">/* useless removes that miss */</span>
<a name="l00189"></a>00189         uint32_t        removeFrees;    <span class="comment">/* removes that freed entry directly */</span>
<a name="l00190"></a>00190         uint32_t        removeEnums;    <span class="comment">/* removes done by Enumerate */</span>
<a name="l00191"></a>00191         uint32_t        grows;          <span class="comment">/* table expansions */</span>
<a name="l00192"></a>00192         uint32_t        shrinks;        <span class="comment">/* table contractions */</span>
<a name="l00193"></a>00193         uint32_t        compresses;     <span class="comment">/* table compressions */</span>
<a name="l00194"></a>00194         uint32_t        enumShrinks;    <span class="comment">/* contractions after Enumerate */</span>
<a name="l00195"></a>00195     } stats;
<a name="l00196"></a>00196 <span class="preprocessor">#endif</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>};
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="comment">/*</span>
<a name="l00200"></a>00200 <span class="comment"> * Size in entries (gross, not net of free and removed sentinels) for table.</span>
<a name="l00201"></a>00201 <span class="comment"> * We store hashShift rather than sizeLog2 to optimize the collision-free case</span>
<a name="l00202"></a>00202 <span class="comment"> * in SearchTable.</span>
<a name="l00203"></a>00203 <span class="comment"> */</span>
<a name="l00204"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a955143a61529fcae181c5189cd5f25df">00204</a> <span class="preprocessor">#define PL_DHASH_TABLE_SIZE(table) \</span>
<a name="l00205"></a>00205 <span class="preprocessor">    ((uint32_t)1 &lt;&lt; (PL_DHASH_BITS - (table)-&gt;hashShift))</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>
<a name="l00207"></a>00207 <span class="comment">/*</span>
<a name="l00208"></a>00208 <span class="comment"> * Table space at entryStore is allocated and freed using these callbacks.</span>
<a name="l00209"></a>00209 <span class="comment"> * The allocator should return null on error only (not if called with nbytes</span>
<a name="l00210"></a>00210 <span class="comment"> * equal to 0; but note that pldhash.c code will never call with 0 nbytes).</span>
<a name="l00211"></a>00211 <span class="comment"> */</span>
<a name="l00212"></a>00212 <span class="keyword">typedef</span> <span class="keywordtype">void</span> *
<a name="l00213"></a><a class="code" href="../../da/d2c/pldhash_8h.html#ab3d0865f6eb9ce090b00466fe1638e54">00213</a> (* PLDHashAllocTable)(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>, uint32_t <a class="code" href="../../d2/d7d/jsapi_8h.html#a80c8d9afd27a344ca543d05abe4209b0">nbytes</a>);
<a name="l00214"></a>00214 
<a name="l00215"></a>00215 <span class="keyword">typedef</span> <a class="code" href="../../d4/da9/png_8h.html#ab30926da86712184b070e550789f8bf7">void</a>
<a name="l00216"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a2fef90cb1cf71590c4241f044af9f799">00216</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a2fef90cb1cf71590c4241f044af9f799">PLDHashFreeTable</a>) (<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>, <span class="keywordtype">void</span> *ptr);
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 <span class="comment">/*</span>
<a name="l00219"></a>00219 <span class="comment"> * Compute the hash code for a given key to be looked up, added, or removed</span>
<a name="l00220"></a>00220 <span class="comment"> * from table.  A hash code may have any PLDHashNumber value.</span>
<a name="l00221"></a>00221 <span class="comment"> */</span>
<a name="l00222"></a>00222 <span class="keyword">typedef</span> <a class="code" href="../../da/d2c/pldhash_8h.html#a6b7adbc70882ca136a7949ca49024cf2">PLDHashNumber</a>
<a name="l00223"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a499fe4b0d58d3ee3e77afa1ea30bea5c">00223</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a499fe4b0d58d3ee3e77afa1ea30bea5c">PLDHashHashKey</a>)   (<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="../../d2/d7d/jsapi_8h.html#a02d8cbd1392e102198d5bb521715f608">key</a>);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="comment">/*</span>
<a name="l00226"></a>00226 <span class="comment"> * Compare the key identifying entry in table with the provided key parameter.</span>
<a name="l00227"></a>00227 <span class="comment"> * Return true if keys match, false otherwise.</span>
<a name="l00228"></a>00228 <span class="comment"> */</span>
<a name="l00229"></a>00229 <span class="keyword">typedef</span> <a class="code" href="../../d7/dd2/qcmstypes_8h.html#acac1f8caeb95c0bd16fe8c0743249831">bool</a>
<a name="l00230"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a453ed2f4b56771d1d676acd094163d60">00230</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a453ed2f4b56771d1d676acd094163d60">PLDHashMatchEntry</a>)(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>, <span class="keyword">const</span> <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *entry,
<a name="l00231"></a>00231                       <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="../../d2/d7d/jsapi_8h.html#a02d8cbd1392e102198d5bb521715f608">key</a>);
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="comment">/*</span>
<a name="l00234"></a>00234 <span class="comment"> * Copy the data starting at from to the new entry storage at to.  Do not add</span>
<a name="l00235"></a>00235 <span class="comment"> * reference counts for any strong references in the entry, however, as this</span>
<a name="l00236"></a>00236 <span class="comment"> * is a &quot;move&quot; operation: the old entry storage at from will be freed without</span>
<a name="l00237"></a>00237 <span class="comment"> * any reference-decrementing callback shortly.</span>
<a name="l00238"></a>00238 <span class="comment"> */</span>
<a name="l00239"></a>00239 <span class="keyword">typedef</span> <a class="code" href="../../d4/da9/png_8h.html#ab30926da86712184b070e550789f8bf7">void</a>
<a name="l00240"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a9d39a773b6f85e539eb2ea0aaaaa86e7">00240</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a9d39a773b6f85e539eb2ea0aaaaa86e7">PLDHashMoveEntry</a>)(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>, <span class="keyword">const</span> <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *from,
<a name="l00241"></a>00241                      <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *<a class="code" href="../../da/d32/prio_8h.html#a5d467a63df9ff99d33d6749038f6f421">to</a>);
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="comment">/*</span>
<a name="l00244"></a>00244 <span class="comment"> * Clear the entry and drop any strong references it holds.  This callback is</span>
<a name="l00245"></a>00245 <span class="comment"> * invoked during a PL_DHASH_REMOVE operation (see below for operation codes),</span>
<a name="l00246"></a>00246 <span class="comment"> * but only if the given key is found in the table.</span>
<a name="l00247"></a>00247 <span class="comment"> */</span>
<a name="l00248"></a>00248 <span class="keyword">typedef</span> <a class="code" href="../../d4/da9/png_8h.html#ab30926da86712184b070e550789f8bf7">void</a>
<a name="l00249"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a217ea1381345b47e1c9c401a2a5394b6">00249</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a217ea1381345b47e1c9c401a2a5394b6">PLDHashClearEntry</a>)(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>, <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *entry);
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">/*</span>
<a name="l00252"></a>00252 <span class="comment"> * Called when a table (whether allocated dynamically by itself, or nested in</span>
<a name="l00253"></a>00253 <span class="comment"> * a larger structure, or allocated on the stack) is finished.  This callback</span>
<a name="l00254"></a>00254 <span class="comment"> * allows table-&gt;ops-specific code to finalize table-&gt;data.</span>
<a name="l00255"></a>00255 <span class="comment"> */</span>
<a name="l00256"></a>00256 <span class="keyword">typedef</span> <a class="code" href="../../d4/da9/png_8h.html#ab30926da86712184b070e550789f8bf7">void</a>
<a name="l00257"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a0609673fd19a71646f494e99fd60d9c9">00257</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a0609673fd19a71646f494e99fd60d9c9">PLDHashFinalize</a>)  (<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>);
<a name="l00258"></a>00258 
<a name="l00259"></a>00259 <span class="comment">/*</span>
<a name="l00260"></a>00260 <span class="comment"> * Initialize a new entry, apart from keyHash.  This function is called when</span>
<a name="l00261"></a>00261 <span class="comment"> * PL_DHashTableOperate&#39;s PL_DHASH_ADD case finds no existing entry for the</span>
<a name="l00262"></a>00262 <span class="comment"> * given key, and must add a new one.  At that point, entry-&gt;keyHash is not</span>
<a name="l00263"></a>00263 <span class="comment"> * set yet, to avoid claiming the last free entry in a severely overloaded</span>
<a name="l00264"></a>00264 <span class="comment"> * table.</span>
<a name="l00265"></a>00265 <span class="comment"> */</span>
<a name="l00266"></a>00266 <span class="keyword">typedef</span> <a class="code" href="../../d7/dd2/qcmstypes_8h.html#acac1f8caeb95c0bd16fe8c0743249831">bool</a>
<a name="l00267"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a9e9f44c5504bccfe60278245aa9f7ade">00267</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a9e9f44c5504bccfe60278245aa9f7ade">PLDHashInitEntry</a>)(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>, <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *entry,
<a name="l00268"></a>00268                      <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="../../d2/d7d/jsapi_8h.html#a02d8cbd1392e102198d5bb521715f608">key</a>);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="comment">/*</span>
<a name="l00271"></a>00271 <span class="comment"> * Finally, the &quot;vtable&quot; structure for PLDHashTable.  The first eight hooks</span>
<a name="l00272"></a>00272 <span class="comment"> * must be provided by implementations; they&#39;re called unconditionally by the</span>
<a name="l00273"></a>00273 <span class="comment"> * generic pldhash.c code.  Hooks after these may be null.</span>
<a name="l00274"></a>00274 <span class="comment"> *</span>
<a name="l00275"></a>00275 <span class="comment"> * Summary of allocation-related hook usage with C++ placement new emphasis:</span>
<a name="l00276"></a>00276 <span class="comment"> *  allocTable          Allocate raw bytes with malloc, no ctors run.</span>
<a name="l00277"></a>00277 <span class="comment"> *  freeTable           Free raw bytes with free, no dtors run.</span>
<a name="l00278"></a>00278 <span class="comment"> *  initEntry           Call placement new using default key-based ctor.</span>
<a name="l00279"></a>00279 <span class="comment"> *                      Return true on success, false on error.</span>
<a name="l00280"></a>00280 <span class="comment"> *  moveEntry           Call placement new using copy ctor, run dtor on old</span>
<a name="l00281"></a>00281 <span class="comment"> *                      entry storage.</span>
<a name="l00282"></a>00282 <span class="comment"> *  clearEntry          Run dtor on entry.</span>
<a name="l00283"></a>00283 <span class="comment"> *  finalize            Stub unless table-&gt;data was initialized and needs to</span>
<a name="l00284"></a>00284 <span class="comment"> *                      be finalized.</span>
<a name="l00285"></a>00285 <span class="comment"> *</span>
<a name="l00286"></a>00286 <span class="comment"> * Note the reason why initEntry is optional: the default hooks (stubs) clear</span>
<a name="l00287"></a>00287 <span class="comment"> * entry storage:  On successful PL_DHashTableOperate(tbl, key, PL_DHASH_ADD),</span>
<a name="l00288"></a>00288 <span class="comment"> * the returned entry pointer addresses an entry struct whose keyHash member</span>
<a name="l00289"></a>00289 <span class="comment"> * has been set non-zero, but all other entry members are still clear (null).</span>
<a name="l00290"></a>00290 <span class="comment"> * PL_DHASH_ADD callers can test such members to see whether the entry was</span>
<a name="l00291"></a>00291 <span class="comment"> * newly created by the PL_DHASH_ADD call that just succeeded.  If placement</span>
<a name="l00292"></a>00292 <span class="comment"> * new or similar initialization is required, define an initEntry hook.  Of</span>
<a name="l00293"></a>00293 <span class="comment"> * course, the clearEntry hook must zero or null appropriately.</span>
<a name="l00294"></a>00294 <span class="comment"> *</span>
<a name="l00295"></a>00295 <span class="comment"> * XXX assumes 0 is null for pointer types.</span>
<a name="l00296"></a>00296 <span class="comment"> */</span>
<a name="l00297"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html">00297</a> <span class="keyword">struct </span><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html">PLDHashTableOps</a> {
<a name="l00298"></a>00298     <span class="comment">/* Mandatory hooks.  All implementations must provide these. */</span>
<a name="l00299"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a047719cfa46e861125eb6e867ad4217a">00299</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#ab3d0865f6eb9ce090b00466fe1638e54">PLDHashAllocTable</a>   <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a047719cfa46e861125eb6e867ad4217a">allocTable</a>;
<a name="l00300"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a4231a3f0cdf30aad272c33546e1633d4">00300</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a2fef90cb1cf71590c4241f044af9f799">PLDHashFreeTable</a>    <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a4231a3f0cdf30aad272c33546e1633d4">freeTable</a>;
<a name="l00301"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a8b40b262493213b5e757b80dd1e31bf6">00301</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a499fe4b0d58d3ee3e77afa1ea30bea5c">PLDHashHashKey</a>      <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a8b40b262493213b5e757b80dd1e31bf6">hashKey</a>;
<a name="l00302"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#ae3427b7257cd24da38a5240c0d71e58f">00302</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a453ed2f4b56771d1d676acd094163d60">PLDHashMatchEntry</a>   <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#ae3427b7257cd24da38a5240c0d71e58f">matchEntry</a>;
<a name="l00303"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a7fec9e7c30192912fe04805d0eba5e46">00303</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a9d39a773b6f85e539eb2ea0aaaaa86e7">PLDHashMoveEntry</a>    <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a7fec9e7c30192912fe04805d0eba5e46">moveEntry</a>;
<a name="l00304"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a0d203176cf45ccf37f75a8d88c47a3a9">00304</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a217ea1381345b47e1c9c401a2a5394b6">PLDHashClearEntry</a>   <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a0d203176cf45ccf37f75a8d88c47a3a9">clearEntry</a>;
<a name="l00305"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a114a8ed07ce7ed9ffb9ffa17715894c7">00305</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a0609673fd19a71646f494e99fd60d9c9">PLDHashFinalize</a>     <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#a114a8ed07ce7ed9ffb9ffa17715894c7">finalize</a>;
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     <span class="comment">/* Optional hooks start here.  If null, these are not called. */</span>
<a name="l00308"></a><a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#aded047bbb648e764d694a00063d220d2">00308</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a9e9f44c5504bccfe60278245aa9f7ade">PLDHashInitEntry</a>    <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html#aded047bbb648e764d694a00063d220d2">initEntry</a>;
<a name="l00309"></a>00309 };
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 <span class="comment">/*</span>
<a name="l00312"></a>00312 <span class="comment"> * Default implementations for the above ops.</span>
<a name="l00313"></a>00313 <span class="comment"> */</span>
<a name="l00314"></a>00314 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span> *
<a name="l00315"></a>00315 <a class="code" href="../../da/d2c/pldhash_8h.html#ad254fdd6ec2fef68935885d4b899800d">PL_DHashAllocTable</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, uint32_t <a class="code" href="../../d2/d7d/jsapi_8h.html#a80c8d9afd27a344ca543d05abe4209b0">nbytes</a>);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00318"></a>00318 <a class="code" href="../../da/d2c/pldhash_8h.html#ac6c645a581a61dc301d60025cefa2f1c">PL_DHashFreeTable</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <span class="keywordtype">void</span> *ptr);
<a name="l00319"></a>00319 
<a name="l00320"></a>00320 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> PLDHashNumber
<a name="l00321"></a>00321 <a class="code" href="../../da/d2c/pldhash_8h.html#ac986d6050ef5d397d0bd1c92472f0405">PL_DHashStringKey</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="../../d2/d7d/jsapi_8h.html#a02d8cbd1392e102198d5bb521715f608">key</a>);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="comment">/* A minimal entry contains a keyHash header and a void key pointer. */</span>
<a name="l00324"></a><a class="code" href="../../d7/d5c/struct_p_l_d_hash_entry_stub.html">00324</a> <span class="keyword">struct </span><a class="code" href="../../d7/d5c/struct_p_l_d_hash_entry_stub.html">PLDHashEntryStub</a> {
<a name="l00325"></a><a class="code" href="../../d7/d5c/struct_p_l_d_hash_entry_stub.html#a70415e14fa19adfad78fe638fdabcea1">00325</a>     <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> <a class="code" href="../../d7/d5c/struct_p_l_d_hash_entry_stub.html#a70415e14fa19adfad78fe638fdabcea1">hdr</a>;
<a name="l00326"></a><a class="code" href="../../d7/d5c/struct_p_l_d_hash_entry_stub.html#a8cb354e359acf2ff3d8e717c3f3bd5a4">00326</a>     <span class="keyword">const</span> <span class="keywordtype">void</span>      *<a class="code" href="../../d7/d5c/struct_p_l_d_hash_entry_stub.html#a8cb354e359acf2ff3d8e717c3f3bd5a4">key</a>;
<a name="l00327"></a>00327 };
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> PLDHashNumber
<a name="l00330"></a>00330 <a class="code" href="../../da/d2c/pldhash_8h.html#a94eb98ee271ac87278f42c58fef4ec42">PL_DHashVoidPtrKeyStub</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="../../d2/d7d/jsapi_8h.html#a02d8cbd1392e102198d5bb521715f608">key</a>);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">bool</span>
<a name="l00333"></a>00333 <a class="code" href="../../da/d2c/pldhash_8h.html#a82a3849676d2839c611a17a2cd9b2927">PL_DHashMatchEntryStub</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table,
<a name="l00334"></a>00334                        <span class="keyword">const</span> <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *entry,
<a name="l00335"></a>00335                        <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="../../d2/d7d/jsapi_8h.html#a02d8cbd1392e102198d5bb521715f608">key</a>);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">bool</span>
<a name="l00338"></a>00338 <a class="code" href="../../da/d2c/pldhash_8h.html#a9528673e0d0b00c09e279c85a70a86ec">PL_DHashMatchStringKey</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table,
<a name="l00339"></a>00339                        <span class="keyword">const</span> <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *entry,
<a name="l00340"></a>00340                        <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="../../d2/d7d/jsapi_8h.html#a02d8cbd1392e102198d5bb521715f608">key</a>);
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00343"></a>00343 <a class="code" href="../../da/d2c/pldhash_8h.html#a18543eda183c163d28ded2e7aa72c926">PL_DHashMoveEntryStub</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table,
<a name="l00344"></a>00344                       <span class="keyword">const</span> <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *from,
<a name="l00345"></a>00345                       <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *<a class="code" href="../../da/d32/prio_8h.html#a5d467a63df9ff99d33d6749038f6f421">to</a>);
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00348"></a>00348 <a class="code" href="../../da/d2c/pldhash_8h.html#a1eb8f30311b9b757d769c5c10df2aedd">PL_DHashClearEntryStub</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *entry);
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00351"></a>00351 <a class="code" href="../../da/d2c/pldhash_8h.html#a225c6a1614e599e2c6a7d030d13f660e">PL_DHashFreeStringKey</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *entry);
<a name="l00352"></a>00352 
<a name="l00353"></a>00353 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00354"></a>00354 <a class="code" href="../../da/d2c/pldhash_8h.html#aea32f3ff64ec5d190a57091f6d44d73e">PL_DHashFinalizeStub</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table);
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">/*</span>
<a name="l00357"></a>00357 <span class="comment"> * If you use PLDHashEntryStub or a subclass of it as your entry struct, and</span>
<a name="l00358"></a>00358 <span class="comment"> * if your entries move via memcpy and clear via memset(0), you can use these</span>
<a name="l00359"></a>00359 <span class="comment"> * stub operations.</span>
<a name="l00360"></a>00360 <span class="comment"> */</span>
<a name="l00361"></a>00361 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keyword">const</span> <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html">PLDHashTableOps</a> *
<a name="l00362"></a>00362 <a class="code" href="../../da/d2c/pldhash_8h.html#ab7cf11b6580c1cae5c7b1e585a6e8f6f">PL_DHashGetStubOps</a>(<span class="keywordtype">void</span>);
<a name="l00363"></a>00363 
<a name="l00364"></a>00364 <span class="comment">/*</span>
<a name="l00365"></a>00365 <span class="comment"> * Dynamically allocate a new PLDHashTable using malloc, initialize it using</span>
<a name="l00366"></a>00366 <span class="comment"> * PL_DHashTableInit, and return its address.  Return null on malloc failure.</span>
<a name="l00367"></a>00367 <span class="comment"> * Note that the entry storage at table-&gt;entryStore will be allocated using</span>
<a name="l00368"></a>00368 <span class="comment"> * the ops-&gt;allocTable callback.</span>
<a name="l00369"></a>00369 <span class="comment"> */</span>
<a name="l00370"></a>00370 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *
<a name="l00371"></a>00371 <a class="code" href="../../da/d2c/pldhash_8h.html#a0780650cfcb536495e14f08d6d979b46">PL_NewDHashTable</a>(<span class="keyword">const</span> <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html">PLDHashTableOps</a> *ops, <span class="keywordtype">void</span> *<a class="code" href="../../d9/d04/expat_8h.html#aa11c5d56dba0976f16f07ea50b1999ba">data</a>, uint32_t entrySize,
<a name="l00372"></a>00372                  uint32_t capacity);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 <span class="comment">/*</span>
<a name="l00375"></a>00375 <span class="comment"> * Finalize table&#39;s data, free its entry storage (via table-&gt;ops-&gt;freeTable),</span>
<a name="l00376"></a>00376 <span class="comment"> * and return the memory starting at table to the malloc heap.</span>
<a name="l00377"></a>00377 <span class="comment"> */</span>
<a name="l00378"></a>00378 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00379"></a>00379 <a class="code" href="../../da/d2c/pldhash_8h.html#a385b83ced39d182fede421d139363238">PL_DHashTableDestroy</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table);
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 <span class="comment">/*</span>
<a name="l00382"></a>00382 <span class="comment"> * Initialize table with ops, data, entrySize, and capacity.  Capacity is a</span>
<a name="l00383"></a>00383 <span class="comment"> * guess for the smallest table size at which the table will usually be less</span>
<a name="l00384"></a>00384 <span class="comment"> * than 75% loaded (the table will grow or shrink as needed; capacity serves</span>
<a name="l00385"></a>00385 <span class="comment"> * only to avoid inevitable early growth from PL_DHASH_MIN_SIZE).</span>
<a name="l00386"></a>00386 <span class="comment"> */</span>
<a name="l00387"></a>00387 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">bool</span>
<a name="l00388"></a>00388 <a class="code" href="../../da/d2c/pldhash_8h.html#a4f58ade853a3afa3b9559bb182bfbf6e">PL_DHashTableInit</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <span class="keyword">const</span> <a class="code" href="../../dc/d8f/struct_p_l_d_hash_table_ops.html">PLDHashTableOps</a> *ops, <span class="keywordtype">void</span> *<a class="code" href="../../d9/d04/expat_8h.html#aa11c5d56dba0976f16f07ea50b1999ba">data</a>,
<a name="l00389"></a>00389                   uint32_t entrySize, uint32_t capacity);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment">/*</span>
<a name="l00392"></a>00392 <span class="comment"> * Set maximum and minimum alpha for table.  The defaults are 0.75 and .25.</span>
<a name="l00393"></a>00393 <span class="comment"> * maxAlpha must be in [0.5, 0.9375] for the default PL_DHASH_MIN_SIZE; or if</span>
<a name="l00394"></a>00394 <span class="comment"> * MinSize=PL_DHASH_MIN_SIZE &lt;= 256, in [0.5, (float)(MinSize-1)/MinSize]; or</span>
<a name="l00395"></a>00395 <span class="comment"> * else in [0.5, 255.0/256].  minAlpha must be in [0, maxAlpha / 2), so that</span>
<a name="l00396"></a>00396 <span class="comment"> * we don&#39;t shrink on the very next remove after growing a table upon adding</span>
<a name="l00397"></a>00397 <span class="comment"> * an entry that brings entryCount past maxAlpha * tableSize.</span>
<a name="l00398"></a>00398 <span class="comment"> */</span>
<a name="l00399"></a>00399 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00400"></a>00400 <a class="code" href="../../da/d2c/pldhash_8h.html#a157254f2d1c343e0f4b185646c76f718">PL_DHashTableSetAlphaBounds</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table,
<a name="l00401"></a>00401                             <span class="keywordtype">float</span> maxAlpha,
<a name="l00402"></a>00402                             <span class="keywordtype">float</span> minAlpha);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404 <span class="comment">/*</span>
<a name="l00405"></a>00405 <span class="comment"> * Call this macro with k, the number of pointer-sized words wasted per entry</span>
<a name="l00406"></a>00406 <span class="comment"> * under chaining, to compute the minimum alpha at which double hashing still</span>
<a name="l00407"></a>00407 <span class="comment"> * beats chaining.</span>
<a name="l00408"></a>00408 <span class="comment"> */</span>
<a name="l00409"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a821f4178dbad173dfde259778dbf7458">00409</a> <span class="preprocessor">#define PL_DHASH_MIN_ALPHA(table, k)                                          \</span>
<a name="l00410"></a>00410 <span class="preprocessor">    ((float)((table)-&gt;entrySize / sizeof(void *) - 1)                         \</span>
<a name="l00411"></a>00411 <span class="preprocessor">     / ((table)-&gt;entrySize / sizeof(void *) + (k)))</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span>
<a name="l00413"></a>00413 <span class="comment">/*</span>
<a name="l00414"></a>00414 <span class="comment"> * Default max/min alpha, and macros to compute the value for the |capacity|</span>
<a name="l00415"></a>00415 <span class="comment"> * parameter to PL_NewDHashTable and PL_DHashTableInit, given default or any</span>
<a name="l00416"></a>00416 <span class="comment"> * max alpha, such that adding entryCount entries right after initializing the</span>
<a name="l00417"></a>00417 <span class="comment"> * table will not require a reallocation (so PL_DHASH_ADD can&#39;t fail for those</span>
<a name="l00418"></a>00418 <span class="comment"> * PL_DHashTableOperate calls).</span>
<a name="l00419"></a>00419 <span class="comment"> *</span>
<a name="l00420"></a>00420 <span class="comment"> * NB: PL_DHASH_CAP is a helper macro meant for use only in PL_DHASH_CAPACITY.</span>
<a name="l00421"></a>00421 <span class="comment"> * Don&#39;t use it directly!</span>
<a name="l00422"></a>00422 <span class="comment"> */</span>
<a name="l00423"></a><a class="code" href="../../da/d2c/pldhash_8h.html#ae1cf773dbc3f9a88a442208a7791299b">00423</a> <span class="preprocessor">#define PL_DHASH_DEFAULT_MAX_ALPHA 0.75</span>
<a name="l00424"></a><a class="code" href="../../da/d2c/pldhash_8h.html#ac13560d269fa0cfd0ef1f8e811b0d7ff">00424</a> <span class="preprocessor"></span><span class="preprocessor">#define PL_DHASH_DEFAULT_MIN_ALPHA 0.25</span>
<a name="l00425"></a>00425 <span class="preprocessor"></span>
<a name="l00426"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a3bf3131cf0925d02ae8d50768d17dce0">00426</a> <span class="preprocessor">#define PL_DHASH_CAP(entryCount, maxAlpha)                                    \</span>
<a name="l00427"></a>00427 <span class="preprocessor">    ((uint32_t)((double)(entryCount) / (maxAlpha)))</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>
<a name="l00429"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a5ba12c7a4288cfb33ba7d1f09f6bf2ae">00429</a> <span class="preprocessor">#define PL_DHASH_CAPACITY(entryCount, maxAlpha)                               \</span>
<a name="l00430"></a>00430 <span class="preprocessor">    (PL_DHASH_CAP(entryCount, maxAlpha) +                                     \</span>
<a name="l00431"></a>00431 <span class="preprocessor">     (((PL_DHASH_CAP(entryCount, maxAlpha) * (uint8_t)(0x100 * (maxAlpha)))     \</span>
<a name="l00432"></a>00432 <span class="preprocessor">       &gt;&gt; 8) &lt; (entryCount)))</span>
<a name="l00433"></a>00433 <span class="preprocessor"></span>
<a name="l00434"></a><a class="code" href="../../da/d2c/pldhash_8h.html#abc05c272f50f369d77ed9e3dbd42e02d">00434</a> <span class="preprocessor">#define PL_DHASH_DEFAULT_CAPACITY(entryCount)                                 \</span>
<a name="l00435"></a>00435 <span class="preprocessor">    PL_DHASH_CAPACITY(entryCount, PL_DHASH_DEFAULT_MAX_ALPHA)</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span>
<a name="l00437"></a>00437 <span class="comment">/*</span>
<a name="l00438"></a>00438 <span class="comment"> * Finalize table&#39;s data, free its entry storage using table-&gt;ops-&gt;freeTable,</span>
<a name="l00439"></a>00439 <span class="comment"> * and leave its members unchanged from their last live values (which leaves</span>
<a name="l00440"></a>00440 <span class="comment"> * pointers dangling).  If you want to burn cycles clearing table, it&#39;s up to</span>
<a name="l00441"></a>00441 <span class="comment"> * your code to call memset.</span>
<a name="l00442"></a>00442 <span class="comment"> */</span>
<a name="l00443"></a>00443 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00444"></a>00444 <a class="code" href="../../da/d2c/pldhash_8h.html#ae916d5104ceaab98849c0e32afbeb308">PL_DHashTableFinish</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table);
<a name="l00445"></a>00445 
<a name="l00446"></a>00446 <span class="comment">/*</span>
<a name="l00447"></a>00447 <span class="comment"> * To consolidate keyHash computation and table grow/shrink code, we use a</span>
<a name="l00448"></a>00448 <span class="comment"> * single entry point for lookup, add, and remove operations.  The operation</span>
<a name="l00449"></a>00449 <span class="comment"> * codes are declared here, along with codes returned by PLDHashEnumerator</span>
<a name="l00450"></a>00450 <span class="comment"> * functions, which control PL_DHashTableEnumerate&#39;s behavior.</span>
<a name="l00451"></a>00451 <span class="comment"> */</span>
<a name="l00452"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519">00452</a> <span class="keyword">typedef</span> <span class="keyword">enum</span> <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519">PLDHashOperator</a> {
<a name="l00453"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519a8582b554e6e8a6b248ba8fce1085f1bf">00453</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519a8582b554e6e8a6b248ba8fce1085f1bf">PL_DHASH_LOOKUP</a> = 0,        <span class="comment">/* lookup entry */</span>
<a name="l00454"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519aca0775d4c66c54e8a0aebeb4ae35061c">00454</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519aca0775d4c66c54e8a0aebeb4ae35061c">PL_DHASH_ADD</a> = 1,           <span class="comment">/* add entry */</span>
<a name="l00455"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519aecda7b7f2dc7c0e4031fae43f933f6fe">00455</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519aecda7b7f2dc7c0e4031fae43f933f6fe">PL_DHASH_REMOVE</a> = 2,        <span class="comment">/* remove entry, or enumerator says remove */</span>
<a name="l00456"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519a43c08cad34a02107c007146be65b0bd9">00456</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519a43c08cad34a02107c007146be65b0bd9">PL_DHASH_NEXT</a> = 0,          <span class="comment">/* enumerator says continue */</span>
<a name="l00457"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519a42bb5cf76c2abee76d01324e25180ea8">00457</a>     <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519a42bb5cf76c2abee76d01324e25180ea8">PL_DHASH_STOP</a> = 1           <span class="comment">/* enumerator says stop */</span>
<a name="l00458"></a>00458 } <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519">PLDHashOperator</a>;
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="comment">/*</span>
<a name="l00461"></a>00461 <span class="comment"> * To lookup a key in table, call:</span>
<a name="l00462"></a>00462 <span class="comment"> *</span>
<a name="l00463"></a>00463 <span class="comment"> *  entry = PL_DHashTableOperate(table, key, PL_DHASH_LOOKUP);</span>
<a name="l00464"></a>00464 <span class="comment"> *</span>
<a name="l00465"></a>00465 <span class="comment"> * If PL_DHASH_ENTRY_IS_BUSY(entry) is true, key was found and it identifies</span>
<a name="l00466"></a>00466 <span class="comment"> * entry.  If PL_DHASH_ENTRY_IS_FREE(entry) is true, key was not found.</span>
<a name="l00467"></a>00467 <span class="comment"> *</span>
<a name="l00468"></a>00468 <span class="comment"> * To add an entry identified by key to table, call:</span>
<a name="l00469"></a>00469 <span class="comment"> *</span>
<a name="l00470"></a>00470 <span class="comment"> *  entry = PL_DHashTableOperate(table, key, PL_DHASH_ADD);</span>
<a name="l00471"></a>00471 <span class="comment"> *</span>
<a name="l00472"></a>00472 <span class="comment"> * If entry is null upon return, then either the table is severely overloaded,</span>
<a name="l00473"></a>00473 <span class="comment"> * and memory can&#39;t be allocated for entry storage via table-&gt;ops-&gt;allocTable;</span>
<a name="l00474"></a>00474 <span class="comment"> * Or if table-&gt;ops-&gt;initEntry is non-null, the table-&gt;ops-&gt;initEntry op may</span>
<a name="l00475"></a>00475 <span class="comment"> * have returned false.</span>
<a name="l00476"></a>00476 <span class="comment"> *</span>
<a name="l00477"></a>00477 <span class="comment"> * Otherwise, entry-&gt;keyHash has been set so that PL_DHASH_ENTRY_IS_BUSY(entry)</span>
<a name="l00478"></a>00478 <span class="comment"> * is true, and it is up to the caller to initialize the key and value parts</span>
<a name="l00479"></a>00479 <span class="comment"> * of the entry sub-type, if they have not been set already (i.e. if entry was</span>
<a name="l00480"></a>00480 <span class="comment"> * not already in the table, and if the optional initEntry hook was not used).</span>
<a name="l00481"></a>00481 <span class="comment"> *</span>
<a name="l00482"></a>00482 <span class="comment"> * To remove an entry identified by key from table, call:</span>
<a name="l00483"></a>00483 <span class="comment"> *</span>
<a name="l00484"></a>00484 <span class="comment"> *  (void) PL_DHashTableOperate(table, key, PL_DHASH_REMOVE);</span>
<a name="l00485"></a>00485 <span class="comment"> *</span>
<a name="l00486"></a>00486 <span class="comment"> * If key&#39;s entry is found, it is cleared (via table-&gt;ops-&gt;clearEntry) and</span>
<a name="l00487"></a>00487 <span class="comment"> * the entry is marked so that PL_DHASH_ENTRY_IS_FREE(entry).  This operation</span>
<a name="l00488"></a>00488 <span class="comment"> * returns null unconditionally; you should ignore its return value.</span>
<a name="l00489"></a>00489 <span class="comment"> */</span>
<a name="l00490"></a>00490 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> * <a class="code" href="../../da/d2c/pldhash_8h.html#a587e8c78b36d501dad502ea7cee7ff2e">PL_DHASH_FASTCALL</a>
<a name="l00491"></a>00491 <a class="code" href="../../da/d2c/pldhash_8h.html#a822adb24721793c9669b80f1c589b6ba">PL_DHashTableOperate</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="../../d2/d7d/jsapi_8h.html#a02d8cbd1392e102198d5bb521715f608">key</a>, <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519">PLDHashOperator</a> op);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 <span class="comment">/*</span>
<a name="l00494"></a>00494 <span class="comment"> * Remove an entry already accessed via LOOKUP or ADD.</span>
<a name="l00495"></a>00495 <span class="comment"> *</span>
<a name="l00496"></a>00496 <span class="comment"> * NB: this is a &quot;raw&quot; or low-level routine, intended to be used only where</span>
<a name="l00497"></a>00497 <span class="comment"> * the inefficiency of a full PL_DHashTableOperate (which rehashes in order</span>
<a name="l00498"></a>00498 <span class="comment"> * to find the entry given its key) is not tolerable.  This function does not</span>
<a name="l00499"></a>00499 <span class="comment"> * shrink the table if it is underloaded.  It does not update stats #ifdef</span>
<a name="l00500"></a>00500 <span class="comment"> * PL_DHASHMETER, either.</span>
<a name="l00501"></a>00501 <span class="comment"> */</span>
<a name="l00502"></a>00502 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00503"></a>00503 <a class="code" href="../../da/d2c/pldhash_8h.html#a136d171f458bfa7c17ce6f4cadcbc0e4">PL_DHashTableRawRemove</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *entry);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 <span class="comment">/*</span>
<a name="l00506"></a>00506 <span class="comment"> * Enumerate entries in table using etor:</span>
<a name="l00507"></a>00507 <span class="comment"> *</span>
<a name="l00508"></a>00508 <span class="comment"> *   count = PL_DHashTableEnumerate(table, etor, arg);</span>
<a name="l00509"></a>00509 <span class="comment"> *</span>
<a name="l00510"></a>00510 <span class="comment"> * PL_DHashTableEnumerate calls etor like so:</span>
<a name="l00511"></a>00511 <span class="comment"> *</span>
<a name="l00512"></a>00512 <span class="comment"> *   op = etor(table, entry, number, arg);</span>
<a name="l00513"></a>00513 <span class="comment"> *</span>
<a name="l00514"></a>00514 <span class="comment"> * where number is a zero-based ordinal assigned to live entries according to</span>
<a name="l00515"></a>00515 <span class="comment"> * their order in table-&gt;entryStore.</span>
<a name="l00516"></a>00516 <span class="comment"> *</span>
<a name="l00517"></a>00517 <span class="comment"> * The return value, op, is treated as a set of flags.  If op is PL_DHASH_NEXT,</span>
<a name="l00518"></a>00518 <span class="comment"> * then continue enumerating.  If op contains PL_DHASH_REMOVE, then clear (via</span>
<a name="l00519"></a>00519 <span class="comment"> * table-&gt;ops-&gt;clearEntry) and free entry.  Then we check whether op contains</span>
<a name="l00520"></a>00520 <span class="comment"> * PL_DHASH_STOP; if so, stop enumerating and return the number of live entries</span>
<a name="l00521"></a>00521 <span class="comment"> * that were enumerated so far.  Return the total number of live entries when</span>
<a name="l00522"></a>00522 <span class="comment"> * enumeration completes normally.</span>
<a name="l00523"></a>00523 <span class="comment"> *</span>
<a name="l00524"></a>00524 <span class="comment"> * If etor calls PL_DHashTableOperate on table with op != PL_DHASH_LOOKUP, it</span>
<a name="l00525"></a>00525 <span class="comment"> * must return PL_DHASH_STOP; otherwise undefined behavior results.</span>
<a name="l00526"></a>00526 <span class="comment"> *</span>
<a name="l00527"></a>00527 <span class="comment"> * If any enumerator returns PL_DHASH_REMOVE, table-&gt;entryStore may be shrunk</span>
<a name="l00528"></a>00528 <span class="comment"> * or compressed after enumeration, but before PL_DHashTableEnumerate returns.</span>
<a name="l00529"></a>00529 <span class="comment"> * Such an enumerator therefore can&#39;t safely set aside entry pointers, but an</span>
<a name="l00530"></a>00530 <span class="comment"> * enumerator that never returns PL_DHASH_REMOVE can set pointers to entries</span>
<a name="l00531"></a>00531 <span class="comment"> * aside, e.g., to avoid copying live entries into an array of the entry type.</span>
<a name="l00532"></a>00532 <span class="comment"> * Copying entry pointers is cheaper, and safe so long as the caller of such a</span>
<a name="l00533"></a>00533 <span class="comment"> * &quot;stable&quot; Enumerate doesn&#39;t use the set-aside pointers after any call either</span>
<a name="l00534"></a>00534 <span class="comment"> * to PL_DHashTableOperate, or to an &quot;unstable&quot; form of Enumerate, which might</span>
<a name="l00535"></a>00535 <span class="comment"> * grow or shrink entryStore.</span>
<a name="l00536"></a>00536 <span class="comment"> *</span>
<a name="l00537"></a>00537 <span class="comment"> * If your enumerator wants to remove certain entries, but set aside pointers</span>
<a name="l00538"></a>00538 <span class="comment"> * to other entries that it retains, it can use PL_DHashTableRawRemove on the</span>
<a name="l00539"></a>00539 <span class="comment"> * entries to be removed, returning PL_DHASH_NEXT to skip them.  Likewise, if</span>
<a name="l00540"></a>00540 <span class="comment"> * you want to remove entries, but for some reason you do not want entryStore</span>
<a name="l00541"></a>00541 <span class="comment"> * to be shrunk or compressed, you can call PL_DHashTableRawRemove safely on</span>
<a name="l00542"></a>00542 <span class="comment"> * the entry being enumerated, rather than returning PL_DHASH_REMOVE.</span>
<a name="l00543"></a>00543 <span class="comment"> */</span>
<a name="l00544"></a>00544 <span class="keyword">typedef</span> <a class="code" href="../../da/d2c/pldhash_8h.html#a1d49536cbc1eec9e5a32af3750697519">PLDHashOperator</a>
<a name="l00545"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a033b176dd6ba5e50ff924fce46bf24bf">00545</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a033b176dd6ba5e50ff924fce46bf24bf">PLDHashEnumerator</a>)(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *<a class="code" href="../../d3/d82/prlink_8h.html#aae95f41aa336f8375a3415100cf9ffd4">table</a>, <a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *hdr, uint32_t number,
<a name="l00546"></a>00546                       <span class="keywordtype">void</span> *<a class="code" href="../../d2/dbe/jsprf_8h.html#ae036856e415526e58e249638733f6752">arg</a>);
<a name="l00547"></a>00547 
<a name="l00548"></a>00548 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> uint32_t
<a name="l00549"></a>00549 <a class="code" href="../../da/d2c/pldhash_8h.html#af55e629846ba2cd127404865c1179cf7">PL_DHashTableEnumerate</a>(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <a class="code" href="../../da/d2c/pldhash_8h.html#a033b176dd6ba5e50ff924fce46bf24bf">PLDHashEnumerator</a> etor, <span class="keywordtype">void</span> *<a class="code" href="../../d2/dbe/jsprf_8h.html#ae036856e415526e58e249638733f6752">arg</a>);
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="keyword">typedef</span> size_t
<a name="l00552"></a><a class="code" href="../../da/d2c/pldhash_8h.html#a4081d85c794b8880aaf154099f1538d6">00552</a> (* <a class="code" href="../../da/d2c/pldhash_8h.html#a4081d85c794b8880aaf154099f1538d6">PLDHashSizeOfEntryExcludingThisFun</a>)(<a class="code" href="../../d0/dcc/struct_p_l_d_hash_entry_hdr.html">PLDHashEntryHdr</a> *hdr,
<a name="l00553"></a>00553                                        mozilla::MallocSizeOf <a class="code" href="../../dd/dc2/plarenas_8h.html#a949eedf624fe531514701f3f304b94a9">mallocSizeOf</a>,
<a name="l00554"></a>00554                                        <span class="keywordtype">void</span> *<a class="code" href="../../d2/dbe/jsprf_8h.html#ae036856e415526e58e249638733f6752">arg</a>);
<a name="l00555"></a>00555 
<a name="l00562"></a>00562 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">size_t</span>
<a name="l00563"></a>00563 <a class="code" href="../../da/d2c/pldhash_8h.html#a5c0fb7f5860f2c9425b3c50cdeab2eeb">PL_DHashTableSizeOfExcludingThis</a>(<span class="keyword">const</span> <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table,
<a name="l00564"></a>00564                                  <a class="code" href="../../da/d2c/pldhash_8h.html#a4081d85c794b8880aaf154099f1538d6">PLDHashSizeOfEntryExcludingThisFun</a> sizeOfEntryExcludingThis,
<a name="l00565"></a>00565                                  mozilla::MallocSizeOf mallocSizeOf,
<a name="l00566"></a>00566                                  <span class="keywordtype">void</span> *<a class="code" href="../../d2/dbe/jsprf_8h.html#ae036856e415526e58e249638733f6752">arg</a> = <a class="code" href="../../db/df5/ncompat_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00567"></a>00567 
<a name="l00571"></a>00571 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">size_t</span>
<a name="l00572"></a>00572 <a class="code" href="../../da/d2c/pldhash_8h.html#aea8b8d1d8d8b6901e5596b0de89f6527">PL_DHashTableSizeOfIncludingThis</a>(<span class="keyword">const</span> <a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table,
<a name="l00573"></a>00573                                  <a class="code" href="../../da/d2c/pldhash_8h.html#a4081d85c794b8880aaf154099f1538d6">PLDHashSizeOfEntryExcludingThisFun</a> sizeOfEntryExcludingThis,
<a name="l00574"></a>00574                                  mozilla::MallocSizeOf mallocSizeOf,
<a name="l00575"></a>00575                                  <span class="keywordtype">void</span> *<a class="code" href="../../d2/dbe/jsprf_8h.html#ae036856e415526e58e249638733f6752">arg</a> = <a class="code" href="../../db/df5/ncompat_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 <span class="preprocessor">#ifdef DEBUG</span>
<a name="l00578"></a>00578 <span class="preprocessor"></span>
<a name="l00592"></a>00592 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00593"></a>00593 PL_DHashMarkTableImmutable(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table);
<a name="l00594"></a>00594 <span class="preprocessor">#endif</span>
<a name="l00595"></a>00595 <span class="preprocessor"></span>
<a name="l00596"></a>00596 <span class="preprocessor">#ifdef PL_DHASHMETER</span>
<a name="l00597"></a>00597 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00598"></a>00598 
<a name="l00599"></a>00599 <a class="code" href="../../d3/dd8/nscore_8h.html#a707a65401f87ac27894dbe2573c692fd">NS_COM_GLUE</a> <span class="keywordtype">void</span>
<a name="l00600"></a>00600 PL_DHashTableDumpMeter(<a class="code" href="../../d9/d33/struct_p_l_d_hash_table.html">PLDHashTable</a> *table, <a class="code" href="../../da/d2c/pldhash_8h.html#a033b176dd6ba5e50ff924fce46bf24bf">PLDHashEnumerator</a> <a class="code" href="../../d6/d1b/pprthred_8h.html#a49e6921d95ff0b994cd312b3f856a8a6">dump</a>, <a class="code" href="../../d1/ddf/ns_i_content_viewer_file_8idl.html#a2a9799b7b2af884315027dd95725e0c3">FILE</a> *<a class="code" href="../../db/da2/namespacejs.html#abf37bb37b825d4bf7c48fad80ed2f349">fp</a>);
<a name="l00601"></a>00601 <span class="preprocessor">#endif</span>
<a name="l00602"></a>00602 <span class="preprocessor"></span>
<a name="l00603"></a>00603 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00604"></a>00604 <span class="preprocessor"></span>}
<a name="l00605"></a>00605 <span class="preprocessor">#endif</span>
<a name="l00606"></a>00606 <span class="preprocessor"></span>
<a name="l00607"></a>00607 <span class="preprocessor">#endif </span><span class="comment">/* pldhash_h___ */</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全て</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>データ構造</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>ネームスペース</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>ファイル</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>関数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>変数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>型定義</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>列挙型</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>列挙型の値</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>フレンド</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>マクロ定義</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../da/d2c/pldhash_8h.html">pldhash.h</a>      </li>

    <li class="footer">FxOS Code Readingに対してSat Oct 19 2013 00:54:46に生成されました。
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
