<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FxOS Code Reading: mediadb.js</title>

<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">FxOS Code Reading
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- 作成： Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'検索');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>メインページ</span></a></li>
      <li><a href="../../pages.html"><span>関連ページ</span></a></li>
      <li><a href="../../modules.html"><span>モジュール</span></a></li>
      <li><a href="../../namespaces.html"><span>パッケージ</span></a></li>
      <li><a href="../../annotated.html"><span>データ構造</span></a></li>
      <li class="current"><a href="../../files.html"><span>ファイル</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>ファイル一覧</span></a></li>
      <li><a href="../../globals.html"><span>グローバル</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('d7/de7/build__stage_2email_2shared_2js_2mediadb_8js.html','../../');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#var-members">変数</a>  </div>
  <div class="headertitle">
<div class="title">mediadb.js</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="../../d7/de7/build__stage_2email_2shared_2js_2mediadb_8js_source.html">ソースコードを見る。</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="var-members"></a>
変数</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">var&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/de7/build__stage_2email_2shared_2js_2mediadb_8js.html#a1c7c277e7990f7e2da74163427e0f830">MediaDB</a></td></tr>
</table>
<hr/><h2>変数</h2>
<a class="anchor" id="a1c7c277e7990f7e2da74163427e0f830"></a><!-- doxytag: member="build_stage/email/shared/js/mediadb.js::MediaDB" ref="a1c7c277e7990f7e2da74163427e0f830" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">var <a class="el" href="../../d0/d93/shared_2js_2mediadb_8js.html#a1c7c277e7990f7e2da74163427e0f830">MediaDB</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>MediaDB.js: a simple interface to DeviceStorage and IndexedDB that serves as a model of the filesystem and provides easy access to the user's media files and their metadata.</p>
<p>Gaia's media apps (Gallery, Music, Videos) read media files from the phone using the DeviceStorage API. They need to keep track of the complete list of media files, as well as the metadata (image thumbnails, song titles, etc.) they have extracted from those files. It would be much too slow to scan the filesystem and read all the metadata from all files each time the apps starts up, so the apps need to store the list of files and metadata in an IndexedDB database. This library integrates both DeviceStorage and IndexedDB into a single API. It keeps the database in sync with the filesystem and provides notifications when files are added or deleted.</p>
<p>CONSTRUCTOR</p>
<p>Create a MediaDB object with the <a class="el" href="../../d7/de7/build__stage_2email_2shared_2js_2mediadb_8js.html#a1c7c277e7990f7e2da74163427e0f830">MediaDB()</a> constructor. It takes three arguments:</p>
<p>mediaType: one of the DeviceStorage media types: "pictures", "movies" or "music".</p>
<p>metadataParser: your metadata parser function. This function should expect three arguments. It will be called with a file to parse and two callback functions. It should read metadata from the file and then pass an object of metadata to the first callback. If parsing fails it should pass an Error object or error message to the second callback. If you omit this argument or pass null, a dummy parser that invokes the callback with an empty object will be used instead.</p>
<p>options: An optional object containing additional MediaDB options. Supported options are:</p>
<p>mimeTypes: an array of MIME types that specifies the kind of files you are interested in and that your metadata parser function knows how to handle. DeviceStorage infers MIME type from filename extension and filters the files it returns based on their extension. Use this property if you want to restrict the set of mime types further.</p>
<p>indexes: an array of IndexedDB key path specifications that specify which properties of each media record should be indexed. If you want to search or sort on anything other than the file name and date you should set this property. "size", and "type" are valid keypaths as is "metadata.x" where x is any metadata property returned by your metadata parser.</p>
<p>version: The version of your IndexedDB database. The default value is 1 Setting it to a larger value will delete all data in the database and rebuild it from scratch. If you ever change your metadata parser function or alter the array of indexes.</p>
<p>autoscan: Whether MediaDB should automatically scan every time it becomes ready. The default is true. If you set this to false you are responsible for calling scan() in response to the 'ready' event.</p>
<p>batchHoldTime: How long (in ms) to wait after finding a new file during a scan before reporting it. Longer hold times allow more batching of changes. The default is 100ms.</p>
<p>batchSize: When batching changes, don't allow the batches to exceed this amount. The default is 0 which means no maximum batch size.</p>
<p>updateRecord: When upgrading database, MediaDB uses this function to ask client app to update the metadata record of specified file. The return value of this function is the updated metadata. If client app does not update any metadata, client app still needs to return file.metadata.</p>
<p>excludeFilter: excludeFilter is used when client app wants MediaDB to filter out additional media files. It must be a regular expression object. The matched files are filtered out. The original filtering behavior of MediaDB will not be change even if excludeFilter is supplied.</p>
<p>MediaDB STATE</p>
<p>A MediaDB object must asynchronously open a connection to its database, and asynchronously check on the availability of device storage, which means that it is not ready for use when first created. After calling the <a class="el" href="../../d7/de7/build__stage_2email_2shared_2js_2mediadb_8js.html#a1c7c277e7990f7e2da74163427e0f830">MediaDB()</a> constructor, register an event listener for 'ready' events with <a class="el" href="../../d8/d0d/transfer_8js.html#abd169909fbdd66534e2d19bf20938d8b">addEventListener()</a> or by setting the onready property. You must not use the MediaDB object until the ready event has been delivered or until the state property is set to MediaDB.READY.</p>
<p>The DeviceStorage API is not always available, and MediaDB is not usable if DeviceStorage is not usable. If the user removes the SD card from their phone, then DeviceStorage will not be able to read or write files, obviously. Also, when a USB Mass Storage session is in progress, DeviceStorage is not available either. If DeviceStorage is not available when a MediaDB object is created, an 'unavailable' event will be fired instead of a 'ready' event. Subsequently, a 'ready' event will be fired whenever DeviceStorage becomes available, and 'unavailable' will be fired whenever DeviceStorage becomes unavailable. Media apps can handle the unavailable case by displaying an informative message in an overlay that prevents all user interaction with the app.</p>
<p>The 'ready' and 'unavailable' events signal changes to the state of a MediaDB object. The state is also available in the state property of the object. The possible values of this property are the following:</p>
<p>Value Constant Meaning ---------------------------------------------------------------------- 'opening' MediaDB.OPENING MediaDB is initializing itself 'upgrading' MediaDB.UPGRADING MediaDB is upgrading database 'ready' MediaDB.READY MediaDB is available and ready for use 'nocard' MediaDB.NOCARD Unavailable because there is no sd card 'unmounted' MediaDB.UNMOUNTED Unavailable because the card is unmounted 'closed' MediaDB.CLOSED Unavailable because <a class="el" href="../../dd/df0/dialogs__end__init_8js.html#acdb1449d11a5550a30ee4a18b9c7f133">close()</a> was called</p>
<p>When an 'unavailable' event is fired, the detail property of the event object specifies the reason that the MediaDB is unavailable. It is one of the state values 'nocard', 'unmounted' or 'closed'.</p>
<p>The 'nocard' state occurs when device storage is not available because there is no SD card in the device. This is typically a permanent failure state, and media apps cannot run without an SD card. It can occur transiently, however, if the user is swapping SD cards while a media app is open.</p>
<p>The 'unmounted' state occurs when the device's SD card is unmounted. This is generally a temporary condition that occurs when the user starts a USB Mass Storage transfer session by plugging their device into a computer. In this case, MediaDB will become available again as soon as the device is unplugged (it may have different files on it, though: see the SCANNING section below).</p>
<p>DATABASE RECORDS</p>
<p>MediaDB stores a record in its IndexedDB database for each DeviceStorage file of the appropriate media type and mime type. The records are objects of this form:</p>
<p>{ name: // the filename (relative to the DeviceStorage root) type: // the file MIME type (extension-based, from DeviceStorage) size: // the file size in bytes date: // file modification time (as ms since the epoch) metadata: // whatever object the metadata parser returned }</p>
<p>Note that the database records do not include the file itself, but only its name. Use the getFile() method to get a <a class="el" href="../../d1/d31/class_file.html">File</a> object (a Blob) by name.</p>
<p>ENUMERATING FILES</p>
<p>Typically, the first thing an app will do with a MediaDB object after the ready event is triggered is call the enumerate() method to obtain the list of files that MediaDB already knows about from previous app invocations. enumerate() gets records from the database and passes them to the specified callback. Each record that is passed to the callback is an object in the form shown above.</p>
<p>If you pass only a callback to enumerate(), it calls the callback once for each entry in the database and then calls the callback with an argument of null to indicate that it is done.</p>
<p>By default, entries are returned in alphabetical order by filename and all entries in the database are returned. You can specify other arguments to enumerate() to change the set of entries that are returned and the order that they are enumerated in. The full set of arguments are:</p>
<p>key: A keypath specification that specifies what field to sort on. If you specify this argument, it must be 'name', 'date', or one of the values in the options.indexes array passed to the <a class="el" href="../../d7/de7/build__stage_2email_2shared_2js_2mediadb_8js.html#a1c7c277e7990f7e2da74163427e0f830">MediaDB()</a> constructor. This argument is optional. If omitted, the default is to use the file name as the key.</p>
<p>range: An IDBKeyRange object that optionally specifies upper and lower bounds on the specified key. This argument is optional. If omitted, all entries in the database are enumerated. See IndexedDB documentation for more on key ranges.</p>
<p>direction: One of the IndexedDB direction string "next", "nextunique", "prev" or "prevunique". This argument is optional. If omitted, the default is "next", which enumerates entries in ascending order.</p>
<p>callback: The function that database entries should be passed to. This argument is not optional, and is always passed as the last argument to enumerate().</p>
<p>The enumerate() method returns database entries. These include file names, but not the files themselves. enumerate() interacts solely with the IndexedDB; it does not use DeviceStorage. If you want to use a media file (to play a song or display a photo, for example) call the getFile() method.</p>
<p>enumerate() returns an object with a 'state' property that starts out as 'enumerating' and switches to 'complete' when the enumeration is done. You can cancel a pending enumeration by passing this object to the cancelEnumeration() method. This switches the state to 'cancelling' and then it switches to 'cancelled' when the cancellation is complete. If you call cancelEnumeration(), the callback function you passed to enumerate() is guaranteed not to be called again.</p>
<p>In addition to enumerate(), there are two other methods you can use to enumerate database entries:</p>
<p><a class="el" href="../../da/d4c/build__stage_2email_2shared_2js_2device__storage_2enumerate__all_8js.html#a6970279a47f99ba5d90af053f5cb9394">enumerateAll()</a> takes the same arguments and returns the same values as enumerate(), but it batches the results and passes them in an array to the callback function.</p>
<p>getAll() takes a callback argument and passes it an array of all entries in the database, sorted by filename. It does not allow you to specify a key, range, or direction, but if you need all entries from the database, this method is is much faster than enumerating entries individually.</p>
<p>FILESYSTEM CHANGES</p>
<p>When media files are added or removed, MediaDB reports this by triggering 'created' and 'deleted' events.</p>
<p>When a 'created' event is fired, the detail property of the event is an array of database record objects. When a single file is created (for example when the user takes a picture with the Camera app) this array has only a single element. But when MediaDB scans for new files (see SCANNING below) it may batch multiple records into a single created event. If a 'created' event has many records, apps may choose to simply rebuild their UI from scratch with a new call to enumerate() instead of handling the new files one at a time.</p>
<p>When a 'deleted' event is fired, the detail property of the event is an array of the names of the files that have been deleted. As with 'created' events, the array may have a single element or may have many batched elements.</p>
<p>If MediaDB detects that a file has been modified in place (because its size or date changes) it treats this as a deletion of the old version and the creation of a new version, and will fire a deleted event followed by a created event.</p>
<p>The created and deleted events are not triggered until the corresponding files have actually been created and deleted and their database records have been updated.</p>
<p>SCANNING</p>
<p>MediaDB automatically scans for new and deleted files every time it enters the MediaDB.READY state. This happens when the MediaDB object is first created, and also when an SD card is removed and reinserted or when the user finishes a USB Mass Storage session. If the scan finds new files, it reports them with one or more 'created' events. If the scan finds that files have been deleted, it reports them with one or more 'deleted' events.</p>
<p>MediaDB fires a 'scanstart' event when a scan begins and fires a 'scanend' event when the scan is complete. Apps can use these events to let the user know that a scan is in progress.</p>
<p>The scan algorithm attempts to quickly look for new files and reports those first. It then begins a slower full scan phase where it checks that each of the files it already knows about is still present.</p>
<p>EVENTS</p>
<p>As described above, MediaDB sends events to communicate with the apps that use it. The event types and their meanings are:</p>
<p>Event Meaning -------------------------------------------------------------------------- ready MediaDB is ready for use. Also fired when new volumes added. unavailable MediaDB is unavailable (often because of USB file transfer) created One or more files were created deleted One or more files were deleted scanstart MediaDB is scanning scanend MediaDB has finished scanning cardremoved A volume became permanently unavailable. Only fired on devices that have internal storage and a card</p>
<p>Because MediaDB is a JavaScript library, these are not real DOM events, but simulations.</p>
<p>MediaDB defines two-argument versions of <a class="el" href="../../d8/d0d/transfer_8js.html#abd169909fbdd66534e2d19bf20938d8b">addEventListener()</a> and <a class="el" href="../../df/d44/permission__manager_8js.html#acf9987ef04ab3791e7ff8b28d748ebcc">removeEventListener()</a> and also allows you to define event handlers by setting 'on' properties like 'onready' and 'onscanstart'.</p>
<p>The objects passed on MediaDB event handlers are not true Event objects but simulate a CustomEvent by defining type, target, currentTarget, timestamp and detail properties. For MediaDB events, it is the detail property that always holds the useful information. These simulated event objects do not have preventDefault(), stopPropagation() or stopImmediatePropagation() methods.</p>
<p>MediaDB events do not bubble and cannot be captured.</p>
<p>INTERNAL AND EXTERNAL STORAGE</p>
<p>Some devices have internal storage and also external (sdcard) storage. MediaDB hides this from apps, for the most part. There are some idiosyncracies to be aware of, however. With more than one device storage area available, MediaDB can remain available even when an sdcard is removed. When this happens we send a 'cardremoved' event instead of an 'unavailable' event. And if there were files on that card, the cardremoved event is followed by a series of deleted events for all of the files.</p>
<p>If a card is inserted, we just send a 'ready' event, and start a new scan, even if we were already in the MediaDB.READY state.</p>
<p>The situation is slightly different when one of the two storage areas is unmounted so it can be shared by USB, however. In this case, the files are only temporarily unavailable, and it doesn't make sense to delete them and then rescan everything when the volume is mounted again. So instead, when either of the storage areas is shared via USB, MediaDB sends its 'unavailable' event.</p>
<p>METHODS</p>
<p>MediaDB defines the following methods:</p>
<ul>
<li><a class="el" href="../../d8/d0d/transfer_8js.html#abd169909fbdd66534e2d19bf20938d8b">addEventListener()</a>: register a function to call when an event is fired</li>
</ul>
<ul>
<li><a class="el" href="../../df/d44/permission__manager_8js.html#acf9987ef04ab3791e7ff8b28d748ebcc">removeEventListener()</a>: unregister an event listener function</li>
</ul>
<ul>
<li>enumerate(): for each file that MediaDB knows about, pass its database record object to the specified callback. By default, records are returned in alphabetical order by name, but optional arguments allow you to specify a database index, a key range, and a sort direction.</li>
</ul>
<ul>
<li>cancelEnumeration(): stops an enumeration in progress. Pass the object returned by enumerate().</li>
</ul>
<ul>
<li>getFile(): given a filename and a callback, this method looks up the named file in DeviceStorage and passes it (a Blob) to the callback. An error callback is available as an optional third argument.</li>
</ul>
<ul>
<li><a class="el" href="../../de/deb/jsdbgapi_8h.html#af811e5c0ef06b777b160f87806b7285e">count()</a>: count the number of records in the database and pass the value to the specified callback. Like enumerate(), this method allows you to specify the name of an index and a key range if you only want to count some of the records.</li>
</ul>
<ul>
<li>updateMetadata(): updates the metadata associated with a named file</li>
</ul>
<ul>
<li>addFile(): given a filename and a blob this method saves the blob as a named file to device storage.</li>
</ul>
<ul>
<li><a class="el" href="../../d0/da2/gallery_8js.html#a1d34740c9f45587facea86c15f99a2c6">deleteFile()</a>: deletes the named file from device storage and the database</li>
</ul>
<ul>
<li><a class="el" href="../../dd/df0/dialogs__end__init_8js.html#acdb1449d11a5550a30ee4a18b9c7f133">close()</a>: closes the IndexedDB connections and stops listening to DeviceStorage events. This permanently puts the MediaDB object into the MediaDB.CLOSED state in which it is unusable.</li>
</ul>
<ul>
<li><a class="el" href="../../d5/dbd/camera_2js_2camera_8js.html#aee0d39ea5b43f5b82d082b8aec6581a8">freeSpace()</a>: call the DeviceStorage <a class="el" href="../../d5/dbd/camera_2js_2camera_8js.html#aee0d39ea5b43f5b82d082b8aec6581a8">freeSpace()</a> method and pass the result to the specified callback </li>
</ul>

<p> <a class="el" href="../../d7/de7/build__stage_2email_2shared_2js_2mediadb_8js_source.html">build_stage/email/shared/js/mediadb.js</a> の <a class="el" href="../../d7/de7/build__stage_2email_2shared_2js_2mediadb_8js_source.html#l00362">362</a> 行で定義されています。</p>

<p>参照元 <a class="el" href="../../de/db0/music_8js_source.html#l00115">init()</a>, <a class="el" href="../../d1/d6b/video_2js_2db_8js_source.html#l00005">initDB()</a>, と <a class="el" href="../../dd/d85/video_8js_source.html#l00468">updateDialog()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>全て</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>データ構造</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>ネームスペース</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>ファイル</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>関数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>変数</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>型定義</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>列挙型</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>列挙型の値</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>フレンド</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>マクロ定義</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="../../d7/de7/build__stage_2email_2shared_2js_2mediadb_8js.html">mediadb.js</a>      </li>

    <li class="footer">FxOS Code Readingに対してSat Oct 19 2013 00:56:15に生成されました。
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
